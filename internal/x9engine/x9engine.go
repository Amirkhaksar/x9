package x9engine

import (
	"bufio"
	"errors"
	"fmt"
	"github.com/ImAyrix/fallparams/funcs/opt"
	"github.com/ImAyrix/fallparams/funcs/run"
	"github.com/ImAyrix/fallparams/funcs/utils"
	"github.com/ImAyrix/fallparams/funcs/validate"
	"github.com/amirkhaksar/x9/internal/generators"
	"github.com/amirkhaksar/x9/internal/options"
	"github.com/amirkhaksar/x9/internal/url_utils"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

var (
	wg sync.WaitGroup
)

func GenerateURLs(args options.X9EngineOptions) ([]string, error) {
	var completeURLs []string
	var paramList []string
	var valueList []string

	if args.Parameters != "" {
		params, err := loadFromFile(args.Parameters)
		if err != nil {
			return nil, err
		}
		paramList = unique(params)
	}
	if args.ValueFile != "" {
		values, err := loadFromFile(args.ValueFile)
		if err != nil {
			return nil, err
		}
		valueList = unique(values)
	}
	if len(args.Value) > 0 {
		valueList = unique(args.Value)
	}
	if args.URLList != "" {
		urls, err := loadFromFile(args.URLList)
		if err != nil {
			return nil, err
		}
		urls = unique(urls)

		for _, url := range urls {
			fullURL, err := url_utils.CleanURL(url)
			if err != nil {
				return nil, err
			}
			completeURLs = append(completeURLs, fullURL)
		}
	} else if args.URL != "" {
		fullURL, err := url_utils.CleanURL(args.URL)
		if err != nil {
			return nil, err
		}
		completeURLs = append(completeURLs, fullURL)
	} else if !isStdinEmpty() {
		inputURLs, err := readStdin()
		if err != nil {
			return nil, err
		}
		if len(inputURLs) == 1 {
			url := inputURLs[0]
			if url != "" {
				if strings.Contains(url, ",") {
					url = strings.Split(url, ",")[0]
				}
				fullURL, err := url_utils.CleanURL(url)
				if err != nil {
					return nil, err
				}
				completeURLs = append(completeURLs, fullURL)
			} else {
				return nil, fmt.Errorf("no URL provided")
			}
		} else {
			inputURLs = unique(inputURLs)
			for _, url := range inputURLs {
				fullURL, err := url_utils.CleanURL(url)
				if err != nil {
					return nil, err
				}
				completeURLs = append(completeURLs, fullURL)
			}
		}
	} else {
		return nil, fmt.Errorf("provide an URL or a file")
	}

	var allGeneratedURLs []string

	if args.UseFallParams {
		for _, valURL := range completeURLs {
			// Create a temporary file for the output
			tmpFile, err := os.CreateTemp("", "fallparams_output_*.txt")
			if err != nil {
				return nil, fmt.Errorf("failed to create temporary file: %w", err)
			}
			// Set up fallparamsOptions for fallparams
			fallparamsOptions := &opt.Options{
				InputUrls:          valURL,
				InputDIR:           "",
				Thread:             args.Threads,
				Delay:              args.Delay,
				CrawlMode:          args.CrawlMode,
				MaxDepth:           args.MaxDepth,
				CrawlDuration:      args.CrawlDuration,
				Headless:           args.Headless,
				CustomHeaders:      args.CustomHeaders,
				OutputFile:         tmpFile.Name(),
				MaxLength:          args.MaxLength,
				MinLength:          args.MinLength,
				DisableUpdateCheck: false,
				RequestHttpMethod:  args.RequestHttpMethod,
				RequestBody:        "",
				InputHttpRequest:   "",
				ProxyUrl:           args.ProxyUrl,
				SilentMode:         args.Silent,
			}

			// Run fallparams
			RunFallParams(fallparamsOptions)

			// Read the parameters from the temporary file
			params, err := loadFromFile(tmpFile.Name())
			if err != nil {
				return nil, fmt.Errorf("failed to read parameters from temporary file: %w", err)
			}

			// Close the temporary file before attempting to remove it
			if err := tmpFile.Close(); err != nil {
				fmt.Printf("failed to close temporary file: %s, error: %v\n", tmpFile.Name(), err)
			}
			// Remove the temporary file
			defer func(name string) {
				err := os.Remove(name)
				if err != nil {
					fmt.Printf("failed to remove temporary file: %s, error: %v\n", name, err)
				}
			}(tmpFile.Name())

			// Combine the parameter list with the parameters generated by fallparams
			paramList = append(paramList, unique(params)...)
		}

		if len(paramList) == 0 {
			return nil, fmt.Errorf("no parameters provided")
		}

		// Generate URLs with the collected parameters
		generatedURLs, err := generators.Strategy(args.GenerateStrategy, completeURLs, valueList, paramList, args.Chunk)
		if err != nil {
			return nil, err
		}
		allGeneratedURLs = append(allGeneratedURLs, generatedURLs...)
	} else {
		if len(paramList) == 0 {
			return nil, fmt.Errorf("no parameters provided")
		}
		// Use the strategy to generate URLs
		generatedURLs, err := generators.Strategy(args.GenerateStrategy, completeURLs, valueList, paramList, args.Chunk)
		if err != nil {
			return nil, err
		}
		allGeneratedURLs = append(allGeneratedURLs, generatedURLs...)
	}

	return allGeneratedURLs, nil
}

func RunFallParams(fallparamsOptions *opt.Options) {
	if fallparamsOptions.InputHttpRequest != "" {
		utils.ParseHttpRequest(fallparamsOptions)
	}
	err := validate.Options(fallparamsOptions)
	utils.CheckError(err)

	var channel = utils.GetInput(fallparamsOptions)
	_, _ = os.Create(fallparamsOptions.OutputFile)

	for i := 0; i < fallparamsOptions.Thread; i++ {
		wg.Add(1)
		go run.Start(channel, fallparamsOptions, &wg)
	}
	wg.Wait()

	defer utils.FinalMessage(fallparamsOptions)
}
func loadFromFile(filePath string) ([]string, error) {
	// Get absolute path
	absPath, err := filepath.Abs(filepath.Clean(filePath))
	if err != nil {
		return nil, fmt.Errorf("failed to get absolute path: %w", err)
	}

	// Read file
	data, err := os.ReadFile(absPath)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return nil, fmt.Errorf("file not found: %s", absPath)
		}
		if errors.Is(err, os.ErrPermission) {
			return nil, fmt.Errorf("permission denied: %s", absPath)
		}
		return nil, fmt.Errorf("failed to read file: %w", err)
	}

	// Split lines
	lines := strings.Split(strings.TrimSpace(string(data)), "\n")
	return lines, nil
}
func readStdin() ([]string, error) {
	var lines []string
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		lines = append(lines, strings.TrimSpace(scanner.Text()))
	}
	return lines, scanner.Err()
}
func isStdinEmpty() bool {
	stat, err := os.Stdin.Stat()
	if err != nil {
		return true
	}
	return stat.Size() == 0
}
func unique(input []string) []string {
	uniqueMap := make(map[string]bool)
	var result []string
	for _, item := range input {
		if _, exists := uniqueMap[item]; !exists {
			uniqueMap[item] = true
			result = append(result, item)
		}
	}
	return result
}
